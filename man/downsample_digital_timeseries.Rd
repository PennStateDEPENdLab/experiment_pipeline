% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{downsample_digital_timeseries}
\alias{downsample_digital_timeseries}
\title{This function downsamples a vector of integers by keeping the mode within each resampled chunk.}
\arguments{
\item{x}{A vector of integer values to be downsampled by retaining the mode in each chunk}

\item{downsamp}{The factor by which data are downsampled (e.g., 3 will reduce the resulting vector 3x)}

\item{demote_zeros}{Logical indicating whether to prefer non-zero modes, even if they are no more likely in a chunk}
}
\value{
A vector of length \code{ceiling(length(x)/downsamp)} with downsampled integers
}
\description{
When downsampling integers, it is difficult to decide on what value should be retained
since simpler subsampling approaches may retain a digital value that is not representative of the local
neighborhood of the vector. This is less of a problem for downsampling of analog channels where we assume
relative continuity across values.

Here, we have adopted the approach of downsampling integers by retaining the most common intger value within
each subset of the vector. For example, if the vector is of length 100 and we are downsampling 10x, then
the function will look within each set of 10 integers and retain the most common value in each.
}
\details{
Note that this function does not allow for multiple modes. If there are multiple modes, it  always
  retains the mode with the lowest integer value in each chunk. The exception is if \code{demote_zeros} is \code{TRUE}.
  In this case, even if there is one non-zero value in a chunk, it will trump any number of zeros. This is helpful for
  TTL codes where a code may be on for part of the higher-frequency time series and we don't want it to become zero
  in the downsampled data.
}
\author{
Michael Hallquist
}
